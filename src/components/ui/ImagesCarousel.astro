---
import { Icon } from 'astro-icon/components';

export interface Props {
  images: string[];
  width?: string;
  height?: string;
  autoplayInterval?: number;
  className?: string;
  animationType?: 'fade' | 'slide' | 'scale' | 'blur';
  showDots?: boolean;
  showArrows?: boolean;
  alt?: string;
}

const {
  images,
  width = "100%",
  height = "400px",
  autoplayInterval = 4000,
  className = "",
  animationType = "fade",
  showDots = true,
  showArrows = true,
  alt = "Imagen del carousel"
} = Astro.props;

const carouselId = `carousel-${Math.random().toString(36).substr(2, 9)}`;
---

<div 
  class={`carousel-container relative overflow-hidden rounded-lg ${className}`}
  style={`width: ${width}; height: ${height};`}
  data-carousel-id={carouselId}
  data-autoplay-interval={autoplayInterval}
  data-animation-type={animationType}
>
  <!-- Contenedor de imágenes -->
  <div class="carousel-track relative w-full h-full">
    {images.map((image, index) => (
      <div 
        class={`carousel-slide absolute inset-0 transition-all duration-700 ease-in-out ${
          index === 0 ? 'opacity-100 visible' : 'opacity-0 invisible'
        } ${animationType === 'slide' ? (index === 0 ? 'translate-x-0' : 'translate-x-full') : ''}
        ${animationType === 'scale' ? (index === 0 ? 'scale-100' : 'scale-110') : ''}
        ${animationType === 'blur' ? (index === 0 ? 'blur-0' : 'blur-sm') : ''}`}
        data-slide-index={index}
      >
        <img 
          src={image} 
          alt={`${alt} ${index + 1}`}
          class="w-full h-full object-cover"
          loading={index === 0 ? "eager" : "lazy"}
        />
        
        <!-- Overlay gradiente sutil -->
        <div class="absolute inset-0 bg-gradient-to-t from-black/20 via-transparent to-transparent pointer-events-none"></div>
      </div>
    ))}
  </div>

  <!-- Controles de navegación (flechas) -->
  {showArrows && images.length > 1 && (
    <>
      <button 
        class="carousel-arrow carousel-prev absolute left-4 top-1/2 -translate-y-1/2 w-10 h-10 bg-black/40 hover:bg-black/60 text-white rounded-full flex items-center justify-center opacity-0 hover:opacity-100 transition-all duration-300 z-10 backdrop-blur-sm"
        aria-label="Imagen anterior"
      >
        <Icon name="mdi:chevron-left" class="w-5 h-5" />
      </button>
      
      <button 
        class="carousel-arrow carousel-next absolute right-4 top-1/2 -translate-y-1/2 w-10 h-10 bg-black/40 hover:bg-black/60 text-white rounded-full flex items-center justify-center opacity-0 hover:opacity-100 transition-all duration-300 z-10 backdrop-blur-sm"
        aria-label="Siguiente imagen"
      >
        <Icon name="mdi:chevron-right" class="w-5 h-5" />
      </button>
    </>
  )}

  <!-- Indicadores de puntos -->
  {showDots && images.length > 1 && (
    <div class="carousel-dots absolute bottom-4 left-1/2 -translate-x-1/2 flex space-x-2 z-10">
      {images.map((_, index) => (
        <button 
          class={`carousel-dot w-3 h-3 rounded-full transition-all duration-300 ${
            index === 0 
              ? 'bg-arvi-primary shadow-lg scale-110' 
              : 'bg-white/50 hover:bg-white/70'
          }`}
          data-dot-index={index}
          aria-label={`Ir a imagen ${index + 1}`}
        ></button>
      ))}
    </div>
  )}

  <!-- Indicador de progreso -->
  <div class="carousel-progress absolute bottom-0 left-0 h-1 bg-arvi-primary/30 transition-all duration-300 ease-linear z-10" style="width: 0%"></div>
</div>

<style>
  .carousel-container {
    background-color: var(--arvi-background2);
  }

  .carousel-container:hover .carousel-arrow {
    opacity: 1;
  }

  /* Animaciones personalizadas para cada tipo */
  .carousel-slide.fade-in {
    animation: fadeInCarousel 0.7s ease-in-out forwards;
  }

  .carousel-slide.fade-out {
    animation: fadeOutCarousel 0.7s ease-in-out forwards;
  }

  .carousel-slide.slide-in-right {
    animation: slideInRight 0.7s ease-in-out forwards;
  }

  .carousel-slide.slide-out-left {
    animation: slideOutLeft 0.7s ease-in-out forwards;
  }

  .carousel-slide.scale-in {
    animation: scaleInCarousel 0.7s ease-in-out forwards;
  }

  .carousel-slide.scale-out {
    animation: scaleOutCarousel 0.7s ease-in-out forwards;
  }

  .carousel-slide.blur-in {
    animation: blurInCarousel 0.7s ease-in-out forwards;
  }

  .carousel-slide.blur-out {
    animation: blurOutCarousel 0.7s ease-in-out forwards;
  }

  /* Definiciones de animaciones */
  @keyframes fadeInCarousel {
    from { opacity: 0; visibility: hidden; }
    to { opacity: 1; visibility: visible; }
  }

  @keyframes fadeOutCarousel {
    from { opacity: 1; visibility: visible; }
    to { opacity: 0; visibility: hidden; }
  }

  @keyframes slideInRight {
    from { 
      opacity: 0; 
      visibility: hidden; 
      transform: translateX(100%); 
    }
    to { 
      opacity: 1; 
      visibility: visible; 
      transform: translateX(0); 
    }
  }

  @keyframes slideOutLeft {
    from { 
      opacity: 1; 
      visibility: visible; 
      transform: translateX(0); 
    }
    to { 
      opacity: 0; 
      visibility: hidden; 
      transform: translateX(-100%); 
    }
  }

  @keyframes scaleInCarousel {
    from { 
      opacity: 0; 
      visibility: hidden; 
      transform: scale(1.1); 
    }
    to { 
      opacity: 1; 
      visibility: visible; 
      transform: scale(1); 
    }
  }

  @keyframes scaleOutCarousel {
    from { 
      opacity: 1; 
      visibility: visible; 
      transform: scale(1); 
    }
    to { 
      opacity: 0; 
      visibility: hidden; 
      transform: scale(0.9); 
    }
  }

  @keyframes blurInCarousel {
    from { 
      opacity: 0; 
      visibility: hidden; 
      filter: blur(10px); 
    }
    to { 
      opacity: 1; 
      visibility: visible; 
      filter: blur(0); 
    }
  }

  @keyframes blurOutCarousel {
    from { 
      opacity: 1; 
      visibility: visible; 
      filter: blur(0); 
    }
    to { 
      opacity: 0; 
      visibility: hidden; 
      filter: blur(10px); 
    }
  }

  /* Efecto hover para los puntos */
  .carousel-dot:hover {
    transform: scale(1.2);
  }

  /* Animación de la barra de progreso */
  .carousel-progress {
    transition: width linear;
  }

  /* Mejoras de accesibilidad */
  .carousel-container:focus-within .carousel-arrow {
    opacity: 1;
  }

  /* Efectos adicionales para mejor UX */
  .carousel-slide img {
    transition: transform 0.3s ease;
  }

  .carousel-container:hover .carousel-slide img {
    transform: scale(1.02);
  }
</style>

<script>
  class ImageCarousel {
    constructor(container) {
      this.container = container;
      this.slides = container.querySelectorAll('.carousel-slide');
      this.dots = container.querySelectorAll('.carousel-dot');
      this.prevBtn = container.querySelector('.carousel-prev');
      this.nextBtn = container.querySelector('.carousel-next');
      this.progressBar = container.querySelector('.carousel-progress');
      
      this.currentIndex = 0;
      this.isAnimating = false;
      this.autoplayInterval = parseInt(container.dataset.autoplayInterval) || 4000;
      this.animationType = container.dataset.animationType || 'fade';
      this.autoplayTimer = null;
      this.progressTimer = null;
      
      this.init();
    }

    init() {
      if (this.slides.length <= 1) return;

      // Event listeners
      this.prevBtn?.addEventListener('click', () => this.prevSlide());
      this.nextBtn?.addEventListener('click', () => this.nextSlide());
      
      this.dots.forEach((dot, index) => {
        dot.addEventListener('click', () => this.goToSlide(index));
      });

      // Pause autoplay on hover
      this.container.addEventListener('mouseenter', () => this.pauseAutoplay());
      this.container.addEventListener('mouseleave', () => this.startAutoplay());

      // Keyboard navigation
      this.container.addEventListener('keydown', (e) => {
        if (e.key === 'ArrowLeft') this.prevSlide();
        if (e.key === 'ArrowRight') this.nextSlide();
      });

      // Touch/swipe support
      this.addTouchSupport();

      // Start autoplay
      this.startAutoplay();
    }

    addTouchSupport() {
      let startX = 0;
      let startY = 0;
      let threshold = 50;

      this.container.addEventListener('touchstart', (e) => {
        startX = e.touches[0].clientX;
        startY = e.touches[0].clientY;
      });

      this.container.addEventListener('touchend', (e) => {
        if (!startX || !startY) return;

        const endX = e.changedTouches[0].clientX;
        const endY = e.changedTouches[0].clientY;
        const diffX = startX - endX;
        const diffY = startY - endY;

        // Check if it's a horizontal swipe
        if (Math.abs(diffX) > Math.abs(diffY) && Math.abs(diffX) > threshold) {
          if (diffX > 0) {
            this.nextSlide();
          } else {
            this.prevSlide();
          }
        }

        startX = 0;
        startY = 0;
      });
    }

    startAutoplay() {
      if (this.autoplayTimer) return;
      
      this.startProgress();
      this.autoplayTimer = setInterval(() => {
        this.nextSlide();
      }, this.autoplayInterval);
    }

    pauseAutoplay() {
      if (this.autoplayTimer) {
        clearInterval(this.autoplayTimer);
        this.autoplayTimer = null;
      }
      this.pauseProgress();
    }

    startProgress() {
      if (this.progressTimer) return;
      
      let progress = 0;
      const increment = 100 / (this.autoplayInterval / 50);
      
      this.progressTimer = setInterval(() => {
        progress += increment;
        if (progress >= 100) {
          progress = 0;
        }
        this.progressBar.style.width = `${progress}%`;
      }, 50);
    }

    pauseProgress() {
      if (this.progressTimer) {
        clearInterval(this.progressTimer);
        this.progressTimer = null;
      }
    }

    resetProgress() {
      this.progressBar.style.width = '0%';
      this.pauseProgress();
      this.startProgress();
    }

    goToSlide(index) {
      if (index === this.currentIndex || this.isAnimating) return;
      
      this.isAnimating = true;
      const direction = index > this.currentIndex ? 'next' : 'prev';
      
      this.animateSlide(this.currentIndex, index, direction);
      this.updateDots(index);
      
      this.currentIndex = index;
      this.resetProgress();
      
      setTimeout(() => {
        this.isAnimating = false;
      }, 700);
    }

    nextSlide() {
      const nextIndex = (this.currentIndex + 1) % this.slides.length;
      this.goToSlide(nextIndex);
    }

    prevSlide() {
      const prevIndex = (this.currentIndex - 1 + this.slides.length) % this.slides.length;
      this.goToSlide(prevIndex);
    }

    animateSlide(fromIndex, toIndex, direction) {
      const fromSlide = this.slides[fromIndex];
      const toSlide = this.slides[toIndex];

      // Remove all animation classes
      this.slides.forEach((slide) => {
        slide.classList.remove('fade-in', 'fade-out', 'slide-in-right', 'slide-out-left', 'scale-in', 'scale-out', 'blur-in', 'blur-out');
      });

      switch (this.animationType) {
        case 'fade':
          fromSlide.classList.add('fade-out');
          toSlide.classList.add('fade-in');
          break;
        case 'slide':
          if (direction === 'next') {
            fromSlide.classList.add('slide-out-left');
            toSlide.classList.add('slide-in-right');
          } else {
            fromSlide.classList.add('slide-out-left');
            toSlide.classList.add('slide-in-right');
          }
          break;
        case 'scale':
          fromSlide.classList.add('scale-out');
          toSlide.classList.add('scale-in');
          break;
        case 'blur':
          fromSlide.classList.add('blur-out');
          toSlide.classList.add('blur-in');
          break;
      }

      // Update visibility
      setTimeout(() => {
        this.slides.forEach((slide, slideIndex) => {
          if (slideIndex === toIndex) {
            slide.classList.add('opacity-100', 'visible');
            slide.classList.remove('opacity-0', 'invisible');
          } else {
            slide.classList.add('opacity-0', 'invisible');
            slide.classList.remove('opacity-100', 'visible');
          }
        });
      }, 350);
    }

    updateDots(activeIndex) {
      this.dots.forEach((dot, dotIndex) => {
        if (dotIndex === activeIndex) {
          dot.classList.add('bg-arvi-primary', 'shadow-lg', 'scale-110');
          dot.classList.remove('bg-white/50');
        } else {
          dot.classList.remove('bg-arvi-primary', 'shadow-lg', 'scale-110');
          dot.classList.add('bg-white/50');
        }
      });
    }
  }

  // Initialize all carousels on page load
  document.addEventListener('DOMContentLoaded', () => {
    const carousels = document.querySelectorAll('.carousel-container');
    carousels.forEach(carousel => {
      new ImageCarousel(carousel);
    });
  });

  // Handle dynamic carousel creation
  document.addEventListener('astro:page-load', () => {
    const carousels = document.querySelectorAll('.carousel-container');
    carousels.forEach(carousel => {
      if (!carousel.hasAttribute('data-initialized')) {
        new ImageCarousel(carousel);
        carousel.setAttribute('data-initialized', 'true');
      }
    });
  });
</script>