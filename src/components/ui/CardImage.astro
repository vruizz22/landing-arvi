---
import { Icon } from 'astro-icon/components';

interface Props {
  // Para una sola imagen (modo original)
  src?: string;
  alt?: string;
  // Para múltiples imágenes (modo carousel)
  images?: string[];
  // Props comunes
  title: string;
  description: string;
  className?: string;
  width?: string;
  height?: string;
  overlayIntensity?: 'light' | 'medium' | 'dark';
  textPosition?: 'bottom' | 'center' | 'top';
  // Props específicas del carousel (solo aplican si hay múltiples imágenes)
  autoplayInterval?: number;
  animationType?: 'fade' | 'slide' | 'scale' | 'blur';
  showDots?: boolean;
  showArrows?: boolean;
}

const { 
  src,
  alt,
  images,
  title,
  description,
  className = "",
  width = "w-full",
  height = "h-96",
  overlayIntensity = "medium",
  textPosition = "bottom",
  autoplayInterval = 4000,
  animationType = "fade",
  showDots = true,
  showArrows = true
} = Astro.props;

// Determinar si es modo carousel o imagen simple
const isCarousel = images && images.length > 1;
const finalImages = isCarousel ? images : (src ? [src] : []);
const finalAlt = alt || title;

// Generar ID único para el carousel
const carouselId = `card-carousel-${Math.random().toString(36).substr(2, 9)}`;

// Configuración del overlay según intensidad
const overlayClasses = {
  light: "from-black/50 via-black/20 to-transparent",
  medium: "from-black/70 via-black/30 to-transparent", 
  dark: "from-black/80 via-black/50 to-transparent"
};

// Configuración de posición del texto
const textPositionClasses = {
  bottom: "justify-end",
  center: "justify-center",
  top: "justify-start"
};
---

<div 
  class={`relative ${width} ${height} rounded-lg overflow-hidden shadow-sm hover:shadow-lg transition-all duration-300 hover:-translate-y-1 group ${className}`}
  data-carousel-id={isCarousel ? carouselId : undefined}
  data-autoplay-interval={isCarousel ? autoplayInterval : undefined}
  data-animation-type={isCarousel ? animationType : undefined}
>
  {isCarousel ? (
    <!-- Modo Carousel -->
    <>
      <!-- Contenedor de imágenes del carousel -->
      <div class="carousel-track relative w-full h-full">
        {finalImages.map((image, index) => (
          <div 
            class={`carousel-slide absolute inset-0 ${
              index === 0 ? 'opacity-100 visible' : 'opacity-0 invisible'
            }`}
            data-slide-index={index}
          >
            <img 
              src={image}
              alt={`${finalAlt} - ${index + 1}`}
              loading={index === 0 ? "eager" : "lazy"}
              class="absolute inset-0 w-full h-full object-cover transition-transform duration-300 group-hover:scale-105" 
            />
          </div>
        ))}
      </div>

      <!-- Controles de navegación (flechas) -->
      {showArrows && finalImages.length > 1 && (
        <>
          <button 
            class="carousel-arrow carousel-prev absolute left-2 top-1/2 -translate-y-1/2 w-8 h-8 bg-black/40 hover:bg-black/60 text-white rounded-full flex items-center justify-center opacity-0 hover:opacity-100 transition-all duration-300 z-20 backdrop-blur-sm"
            aria-label="Imagen anterior"
          >
            <Icon name="mdi:chevron-left" class="w-4 h-4" />
          </button>
          
          <button 
            class="carousel-arrow carousel-next absolute right-2 top-1/2 -translate-y-1/2 w-8 h-8 bg-black/40 hover:bg-black/60 text-white rounded-full flex items-center justify-center opacity-0 hover:opacity-100 transition-all duration-300 z-20 backdrop-blur-sm"
            aria-label="Siguiente imagen"
          >
            <Icon name="mdi:chevron-right" class="w-4 h-4" />
          </button>
        </>
      )}

      <!-- Indicadores de puntos -->
      {showDots && finalImages.length > 1 && (
        <div class="carousel-dots absolute bottom-14 left-1/2 -translate-x-1/2 flex space-x-1 z-20">
          {finalImages.map((_, index) => (
            <button 
              class={`carousel-dot w-2 h-2 rounded-full transition-all duration-300 ${
                index === 0 ? 'bg-white' : 'bg-white/50'
              } hover:bg-white hover:scale-110`}
              data-slide-index={index}
              aria-label={`Ir a imagen ${index + 1}`}
            ></button>
          ))}
        </div>
      )}

      <!-- Indicador de progreso -->
      <div class="carousel-progress absolute bottom-0 left-0 h-1 bg-arvi-primary/50 transition-all duration-300 ease-linear z-20" style="width: 0%"></div>
    </>
  ) : (
    <!-- Modo Imagen Simple -->
    <img 
      src={finalImages[0]}
      alt={finalAlt}
      class="absolute inset-0 w-full h-full object-cover transition-transform duration-300 group-hover:scale-105" 
    />
  )}
  
  <!-- Overlay para mejorar legibilidad del texto (común para ambos modos) -->
  <div class={`absolute inset-0 bg-gradient-to-t ${overlayClasses[overlayIntensity]} transition-opacity duration-300 group-hover:opacity-80 z-10`}></div>
  
  <!-- Contenido superpuesto (común para ambos modos) -->
  <div class={`absolute inset-0 p-6 flex flex-col ${textPositionClasses[textPosition]} text-center text-white z-15`}>
    <div class="transform transition-transform duration-300 group-hover:translate-y-[-4px]">
      <h4 class="mb-2 text-3xl font-heading text-arvi-primary font-semibold drop-shadow-md">
        {title}
      </h4>
      <p class="text-lg text-white/90 drop-shadow-sm leading-relaxed">
        {description}
      </p>
    </div>
  </div>
  
  <!-- Efecto de brillo sutil en hover (común para ambos modos) -->
  <div class="absolute inset-0 bg-white/10 opacity-0 group-hover:opacity-20 transition-opacity duration-300 pointer-events-none z-5"></div>
</div>

{isCarousel && (
  <style>
    /* Estilos específicos para el carousel en CardImage */
    .carousel-container:hover .carousel-arrow {
      opacity: 1;
    }

    .carousel-dot:hover {
      transform: scale(1.2);
    }

    .carousel-progress {
      transition: width linear;
    }

    .carousel-container:focus-within .carousel-arrow {
      opacity: 1;
    }

    .carousel-slide img {
      transition: transform 0.3s ease;
    }

    .carousel-container:hover .carousel-slide img {
      transform: scale(1.02);
    }

    /* Animaciones de carousel específicas para CardImage */
    .carousel-slide.animate-fade-in,
    .carousel-slide.animate-fade-out,
    .carousel-slide.animate-slide-in-right,
    .carousel-slide.animate-slide-out-left,
    .carousel-slide.animate-slide-in-left,
    .carousel-slide.animate-slide-out-right,
    .carousel-slide.animate-zoom-in,
    .carousel-slide.animate-zoom-out,
    .carousel-slide.animate-blurred-fade-in {
      animation-duration: 0.7s !important;
      animation-fill-mode: forwards !important;
      animation-timing-function: ease-in-out !important;
    }
  </style>
)}

{isCarousel && (
  <script define:vars={{ carouselId, autoplayInterval, animationType }}>
    // Reutilizar la lógica del ImageCarousel pero adaptada para CardImage
    class CardImageCarousel {
      constructor(container) {
        this.container = container;
        this.slides = container.querySelectorAll('.carousel-slide');
        this.dots = container.querySelectorAll('.carousel-dot');
        this.prevBtn = container.querySelector('.carousel-prev');
        this.nextBtn = container.querySelector('.carousel-next');
        this.progressBar = container.querySelector('.carousel-progress');
        
        this.currentIndex = 0;
        this.isAnimating = false;
        this.autoplayInterval = parseInt(container.dataset.autoplayInterval) || 4000;
        this.animationType = container.dataset.animationType || 'fade';
        this.autoplayTimer = null;
        this.progressTimer = null;
        
        this.init();
      }

      init() {
        if (this.slides.length <= 1) return;

        // Event listeners
        this.prevBtn?.addEventListener('click', () => this.prevSlide());
        this.nextBtn?.addEventListener('click', () => this.nextSlide());
        
        this.dots.forEach((dot, index) => {
          dot.addEventListener('click', () => this.goToSlide(index));
        });

        // Pause autoplay on hover
        this.container.addEventListener('mouseenter', () => this.pauseAutoplay());
        this.container.addEventListener('mouseleave', () => this.startAutoplay());

        // Keyboard navigation
        this.container.addEventListener('keydown', (e) => {
          if (e.key === 'ArrowLeft') this.prevSlide();
          if (e.key === 'ArrowRight') this.nextSlide();
        });

        // Touch/swipe support
        this.addTouchSupport();

        // Start autoplay
        this.startAutoplay();
      }

      addTouchSupport() {
        let startX = 0;
        let threshold = 50;

        this.container.addEventListener('touchstart', (e) => {
          startX = e.touches[0].clientX;
        });

        this.container.addEventListener('touchend', (e) => {
          const endX = e.changedTouches[0].clientX;
          const diff = startX - endX;

          if (Math.abs(diff) > threshold) {
            if (diff > 0) {
              this.nextSlide();
            } else {
              this.prevSlide();
            }
          }
        });
      }

      startAutoplay() {
        if (this.autoplayTimer) return;
        
        this.startProgress();
        this.autoplayTimer = setInterval(() => {
          this.nextSlide();
        }, this.autoplayInterval);
      }

      pauseAutoplay() {
        if (this.autoplayTimer) {
          clearInterval(this.autoplayTimer);
          this.autoplayTimer = null;
        }
        this.pauseProgress();
      }

      startProgress() {
        if (this.progressTimer) return;
        
        let progress = 0;
        const increment = 100 / (this.autoplayInterval / 50);
        
        this.progressTimer = setInterval(() => {
          progress += increment;
          if (progress >= 100) progress = 100;
          this.progressBar.style.width = `${progress}%`;
        }, 50);
      }

      pauseProgress() {
        if (this.progressTimer) {
          clearInterval(this.progressTimer);
          this.progressTimer = null;
        }
      }

      resetProgress() {
        this.progressBar.style.width = '0%';
        this.pauseProgress();
        this.startProgress();
      }

      goToSlide(index) {
        if (index === this.currentIndex || this.isAnimating) return;
        
        this.isAnimating = true;
        const direction = index > this.currentIndex ? 'next' : 'prev';
        
        this.animateSlide(this.currentIndex, index, direction);
        this.updateDots(index);
        
        this.currentIndex = index;
        this.resetProgress();
        
        setTimeout(() => {
          this.isAnimating = false;
        }, 700);
      }

      nextSlide() {
        const nextIndex = (this.currentIndex + 1) % this.slides.length;
        this.goToSlide(nextIndex);
      }

      prevSlide() {
        const prevIndex = (this.currentIndex - 1 + this.slides.length) % this.slides.length;
        this.goToSlide(prevIndex);
      }

      animateSlide(fromIndex, toIndex, direction) {
        const fromSlide = this.slides[fromIndex];
        const toSlide = this.slides[toIndex];

        // Remove all animation classes
        this.slides.forEach((slide) => {
          slide.classList.remove(
            'animate-fade-in', 'animate-fade-out',
            'animate-slide-in-right', 'animate-slide-out-left',
            'animate-slide-in-left', 'animate-slide-out-right',
            'animate-zoom-in', 'animate-zoom-out',
            'animate-blurred-fade-in'
          );
        });

        // Apply animations based on type
        switch (this.animationType) {
          case 'fade':
            fromSlide.classList.add('animate-fade-out');
            toSlide.classList.add('animate-fade-in');
            break;
          case 'slide':
            if (direction === 'next') {
              fromSlide.classList.add('animate-slide-out-left');
              toSlide.classList.add('animate-slide-in-right');
            } else {
              fromSlide.classList.add('animate-slide-out-right');
              toSlide.classList.add('animate-slide-in-left');
            }
            break;
          case 'scale':
            fromSlide.classList.add('animate-zoom-out');
            toSlide.classList.add('animate-zoom-in');
            break;
          case 'blur':
            fromSlide.classList.add('animate-fade-out');
            toSlide.classList.add('animate-blurred-fade-in');
            break;
        }

        // Update visibility
        setTimeout(() => {
          this.slides.forEach((slide, index) => {
            if (index === toIndex) {
              slide.classList.remove('opacity-0', 'invisible');
              slide.classList.add('opacity-100', 'visible');
            } else {
              slide.classList.remove('opacity-100', 'visible');
              slide.classList.add('opacity-0', 'invisible');
            }
          });
        }, 350);
      }

      updateDots(activeIndex) {
        this.dots.forEach((dot, index) => {
          if (index === activeIndex) {
            dot.classList.remove('bg-white/50');
            dot.classList.add('bg-white');
          } else {
            dot.classList.remove('bg-white');
            dot.classList.add('bg-white/50');
          }
        });
      }
    }

    // Initialize carousel when DOM is ready
    document.addEventListener('DOMContentLoaded', () => {
      const cardCarousel = document.querySelector(`[data-carousel-id="${carouselId}"]`);
      if (cardCarousel && !cardCarousel.hasAttribute('data-initialized')) {
        new CardImageCarousel(cardCarousel);
        cardCarousel.setAttribute('data-initialized', 'true');
      }
    });

    // Handle Astro page loads
    document.addEventListener('astro:page-load', () => {
      const cardCarousel = document.querySelector(`[data-carousel-id="${carouselId}"]`);
      if (cardCarousel && !cardCarousel.hasAttribute('data-initialized')) {
        new CardImageCarousel(cardCarousel);
        cardCarousel.setAttribute('data-initialized', 'true');
      }
    });
  </script>
)}
